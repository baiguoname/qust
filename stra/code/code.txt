let gg1 = rof::<Vec<((Iocond, Iocond), (CondWeight, CondWeight))>>("gg1", "D:/Rust/pmsbox/stral2");
let gg2 = rof::<Vec<((Iocond, Iocond), (CondWeight, CondWeight))>>("gg2", "D:/Rust/pmsbox/stral2");
let gg3 = rof::<Vec<(CondWeight, CondWeight)>>("gg3", "D:/Rust/pmsbox/stral2");
let gg4 = rof::<Vec<DiName>>("gg4", "D:/Rust/pmsbox/stral2");

let stral1 = gg1.into_iter().map(|x| c25::PTM.clone().get_cond2((&x.0.0, &x.0.1), (&x.1.0, &x.1.1))).collect::<Vec<_>>();
let stral2 = gg2.into_iter().map(|x| c66::PTM.clone().get_cond2((&x.0.0, &x.0.1), (&x.1.0, &x.1.1))).collect::<Vec<_>>();
let stral3 = gg3.into_iter().map(|x| c71::PTM.clone().get_cond3((&x.0, &x.1))).collect::<Vec<_>>();
let ptm_vec = vec![stral1, stral2, stral3].concat();
c25::PTM.clone();
:dep csv
let mut reader = csv::Reader::from_path("D:/Rust/pmsbox/stral2/weight_vec.csv")?;
let gg5 = reader.records().map(|x| x.unwrap()[0].parse::<f32>().unwrap()).collect::<Vec<_>>();
let stra_vec = izip!(
    gg5.iter(),
    gg4.iter(),
    ptm_vec.iter(),
)
.map(|(x, y, z)| {
    match z {
        Ptm::Ptm2(_, stp1, stp2) => {
            let ptm = Ptm::Ptm2(Box::new(M1(*x)), stp1.clone(), stp2.clone());
            Stra(y.clone(), ptm)
        },
        _ => panic!(),
    }
})
.collect::<Vec<_>>();
fn get_cond1(x: &Ptm) -> ((Iocond, Iocond), (CondWeight, CondWeight)) {
    if let Ptm::PtmWeight2(
        StpWeight(Stp(Tsig::TsigFilter(_, iocond1)), cond_weight1),
        StpWeight(Stp(Tsig::TsigFilter(_, iocond2)), cond_weight2)) = x {
        ((iocond1.clone(), iocond2.clone()), (cond_weight1.clone(), cond_weight2.clone()))
    } else {
        panic!();
    }
}

fn get_cond2(x: &Ptm) -> (CondWeight, CondWeight) {
    if let Ptm::PtmWeight2(
        StpWeight(Stp(Tsig::Tsig(_, _, _, _)), cond_weight1),
        StpWeight(Stp(Tsig::Tsig(_, _, _, _)), cond_weight2)) = x {
            (cond_weight1.clone(), cond_weight2.clone())
        } else { panic!(); }
}
let stral1 = Stral(stral.0[0..174].to_vec());
let stral2 = Stral(stral.0[174..254].to_vec());
let stral3 = Stral(stral.0[254..274].to_vec());
let gg1 = stral1.0.iter().map(|x| get_cond1(&x.1)).collect::<Vec<_>>();
let gg2 = stral2.0.iter().map(|x| get_cond1(&x.1)).collect::<Vec<_>>();
let gg3 = stral3.0.iter().map(|x| get_cond2(&x.1)).collect::<Vec<_>>();
gg1.sof("gg1", "D:/Rust/pmsbox/stral2");
gg2.sof("gg2", "D:/Rust/pmsbox/stral2");
gg3.sof("gg3", "D:/Rust/pmsbox/stral2");
stral.0.iter().map(|x| x.0.clone()).collect::<Vec<_>>().sof("gg4", "D:/Rust/pmsbox/stral2");
let stral = Stral(stra_vec);


pub fn spy_on_forecast(ticker: Ticker, data: &Arc<ForecastType>) {
    thread::spawn({
        let data = Arc::clone(data);
        move || {
            let mut guard = data.0.lock().unwrap();
            let cv = &data.1;
            loop {
                guard = cv.wait(guard).unwrap();
                let res = guard.1.iter().map(|x| x.0).sum::<f32>();
                println!("{} new forecast: {}", ticker, res);
                if !guard.0 {
                    println!("the spy on {:?} exit", data.2);
                    break
                }
            }
        }
    });
}

pub fn change_on_forecast(data: &Arc<ForecastType>) {
    thread::spawn({
        let data = Arc::clone(data);
        move || {
            let mut rng = thread_rng();
            let range_for_v = UniformInt::<i32>::new_inclusive(1, 500);
            loop {
                let rand_v = range_for_v.sample(&mut rng) as f32;
                {
                    let mut data_lock = data.0.lock().unwrap();
                    data_lock.1[0] = Forecast(rand_v);
                    data.notify();
                }
                thread::sleep(Duration::from_millis(1_000));
            }
        }
    });
}

/* #region Some */
use rand::{
    distributions::uniform::{Uniform, UniformInt, UniformSampler},
    thread_rng, Rng,
};

pub fn change_data_on_background(data: &Arc<ForecastInfo<i32>>) {
    thread::spawn({
        let data = Arc::clone(data);
        move || {
            let mut rng = thread_rng();
            let range_for_v = UniformInt::<i32>::new_inclusive(1, 500);
            let range_for_sleep = UniformInt::<u64>::new_inclusive(500, 3000);
            for _ in 1..100 {
                let rand_v = range_for_v.sample(&mut rng);
                let rand_time = range_for_sleep.sample(&mut rng);
                {
                    let mut data_lock = data.0.lock().unwrap();
                    data_lock.1 = rand_v;
                    data.1.notify_all();
                    if !data_lock.0 { 
                        println!("exit something {:?}", data.2);
                        break
                    }
                }
                thread::sleep(Duration::from_millis(rand_time));
            }
        }
    });
}

pub fn spy_on_data(data: &Arc<ForecastInfo<i32>>) {
    thread::spawn({
        let data = Arc::clone(data);
        move || {
            let mut guard = data.0.lock().unwrap();
            let cv = &data.1;
            loop {
                guard = cv.wait(guard).unwrap();
                println!("{:?}: the now changed to {:?}", data.2, guard.1);
                if !guard.0 {
                    println!("the spy on {:?} exit", data.2);
                    break
                }
            }
        }
    });
}
/* #endregion */